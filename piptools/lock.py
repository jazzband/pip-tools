import hashlib
import os.path
import re
from collections import OrderedDict

from .logging import log
from .utils import dedup


def check(locks):
    """Check whether `locks` (generated by `lock.generate_locks`) are still valid"""
    if not locks:
        return False

    valid = True
    for lock in locks.values():
        hexdigest, src_file = lock.split()
        checksum = hashlib.sha256()
        with open(src_file, "rb") as f:
            checksum.update(f.read())
        if hexdigest[7:] != checksum.hexdigest():
            log.debug("{} has changed since lock was generated".format(src_file))
            valid = False

    return valid


def generate_locks(*src_files):
    """Generate locks for one or more `src_files`

    Returns a lock that can be written to a separate output file to be checked
    at a later date. The lock then acts as a cache for that output requirements
    file; if the lock is still valid the output file doesn't need to be
    re-generated. The lock becomes invalid if any of the `src_files` used to
    create the lock are changed in the interim.
    """

    # Recursively find all files that might affect an output requirements file
    def walk_requirements(*req_files):
        for req_file in req_files:
            yield req_file
            with open(req_file) as f:
                for line in f:
                    if line.startswith(("-r", "-c")):
                        sub_req_file = line.split()[1]
                        for sub_req_file_ in walk_requirements(sub_req_file):
                            yield sub_req_file_

    src_files = dedup(walk_requirements(*src_files))

    locks = OrderedDict()
    for src_file in src_files:
        checksum = hashlib.sha256()
        with open(src_file, "rb") as f:
            checksum.update(f.read())
        locktxt = "sha256:{}  {}"
        locks[src_file] = locktxt.format(checksum.hexdigest(), src_file)

    return locks


def read_locks(locked_file):
    """Read locks from `locked_file`

    Returns any locks found.
    """
    locks = OrderedDict()

    if not os.path.isfile(locked_file):
        raise ValueError("No such file: '{}'".format(locked_file))

    with open(locked_file) as f:
        for line in f:
            match = re.match(r"(?:#\s+)?(sha256:[a-f0-9]{64}  (.*))$", line)
            if match:
                log.debug("{}: found lock for {}".format(locked_file, match.group(2)))
                locks[match.group(2)] = match.group(1)

    return locks
